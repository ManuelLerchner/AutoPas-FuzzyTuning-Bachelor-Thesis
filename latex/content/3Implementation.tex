\chapter{Implementation}
\label{sec:implementation}

\newcommand{\fuzzySetNodeOneD}[4]{
  \begin{tikzpicture}
    \begin{axis}%
      [
        axis line style={black},
        width=4.5cm,
        height=3cm,
        axis lines=center,
        xlabel={#1},
        x label style={at={(axis description cs:0.9,0.25)},anchor=north},
        ylabel=$\mu$,
        y label style={at={(axis description cs:0.5,1)},anchor=south},
        xmin=-6,
        xmax=6,
        ytick={},
        yticklabels={},
        extra x ticks={0},
        extra x tick labels={#3},
        ymax=1,
        samples=25,
        extra y ticks={1},
        every axis plot/.append style={thick}
      ]
      \addplot[red]  {#4};
    \end{axis}
    \node[above,font=\large\bfseries,inner sep=5pt] at (current bounding box.north) {\shortstack{FuzzySet\\#2}};
  \end{tikzpicture}
}

\newcommand{\fuzzySetNodeTwoD}[4]{
  \begin{tikzpicture}
    \begin{axis}%
      [
        width=5.5cm,
        height=4cm,
        axis lines=center,
        xlabel={#1},
        x label style={at={(axis description cs:0.1,0.4)},anchor=north},
        ylabel={#2},
        y label style={at={(axis description cs:0.4,-0.15)},anchor=south},
        zlabel=$\mu$,
        z label style={at={(axis description cs:0.5,0.95)},anchor=south},
        xmin=-6,
        xmax=6,
        colormap/viridis,
        view={10}{40},
        ymin=-6,
        ymax=6,
        zmin=0,
        zmax=1,
      ]
      \addplot3 [
        domain=-6:6,
        samples = 20,
        surf,
      ]{#4};
    \end{axis}
    \node[above,font=\large\bfseries,inner sep=5pt] at (current bounding box.north) { \shortstack{FuzzySet\\#3}};
  \end{tikzpicture}
}


This chapter describes the implementation of the Fuzzy Tuning technique in AutoPas. The implementation is divided into two main parts: the Fuzzy Tuning framework and the Tuning Strategy. The Fuzzy Tuning framework is the core of this implementation and implements the mathematical foundation of this technique. The Tuning Strategy acts as the interface between the Fuzzy Tuning framework and the AutoPas simulation and is therefore responsible for updating the configuration queue of AutoPas.

\section{Fuzzy Tuning Framework}

The Fuzzy Tuning framework implements the mathematical foundation of the Fuzzy Tuning technique. It consists of several components that work together to apply the Fuzzy Rules to the input variables and generate the output variables. The components of the Fuzzy Tuning framework are as follows:

\begin{itemize}
  \item \textbf{Crisp Set:} The Crisp Set is used to model k-cells used as the underlying sets over which the Fuzzy Sets are defined. A k-cell is a hyperrectangle in the k-dimensional space constructed from the Cartesian product of k intervals $I = I_1 \times I_2 \times \ldots \times I_k$ where $I_i = [x_{low}, x_{high}] \subset \mathbb{R} $ is an interval in the real numbers. They are used to define the underlying sets over which the corresponding fuzzy set is defined and can be thought of as the parameter space of the input variable.


  \item \textbf{Fuzzy Set:} A fuzzy set consists of a membership function that assigns a degree of membership to each element of the Crisp Set. There are two types of membership functions: The \texttt{BaseMembershipFunction} and the \texttt{CompositeMembershipFunction}. The \texttt{BaseMembershipFunction} implement a function $f: \mathbb{R} \rightarrow [0, 1]$ that directly maps the crisp value to the degree of membership. The \texttt{CompositeMembershipFunction} is used to create new fuzzy sets by recursively combining existing fuzzy sets and their membership functions with generic functions. This helps to split up the complex fuzzy sets of the rule base into smaller, more manageable parts. Lets say we have a fuzzy set $\tilde{A}$ defined over the Crisp Set $X$ and a fuzzy set $\tilde{B}$ defined over the Crisp Set $Y$. Both membership functions are functions mapping the respective Crisp Set to the degree of membership ($\mu_{\tilde{A}}: X \rightarrow [0, 1]$ and $\mu_{\tilde{B}}: Y \rightarrow [0, 1]$). Since both membership functions directly map the Crisp Set to the degree of membership, they are considered \texttt{BaseMembershipFunction}s. When we want to create a new fuzzy set $\tilde{C} = \tilde{A} \cap \tilde{B}$ this new fuzzy set is defined over the Crisp Set $X \times Y$  and thus needs to provide a membership function $\mu_{\tilde{C}}: X \times Y \rightarrow [0, 1]$. As described in \todo{add chcpter} this membership function is defined as $\mu_{\tilde{C}}(x, y) = \min(\mu_{\tilde{A}}(x), \mu_{\tilde{B}}(y))$, which can be thought of as recursively combining the membership functions of $\tilde{A}$ and $\tilde{B}$ with the minimum function.

        This way of combining fuzzy sets builds a tree structure where the leafs calculate a direct membership value and the inner nodes combine the membership values of their children and pass them up to their parent. \autoref{fig:modularfuzzysetconstruction} shows an example of how a complex fuzzy set can be constructed from simpler fuzzy sets using this method.

  \item \textbf{Linguistic Variable:} A linguistic variable is a variable whose values are terms in a natural language. Each term is associated with a fuzzy set that defines its concept using the language of fuzzy logic. The linguistic variables can then be used to express rules in a human-readable way.

  \item \textbf{Fuzzy Rule:} A fuzzy rule is a conditional statement that describes the relationship between input- and output variables. It consists of an antecedent and a consequent both of which are fuzzy sets. During the evaluation of the rule, the antecedent is evaluated to determine the degree to which the rule is satisfied and thus the effect of the rule can be reduced accordingly.

  \item \textbf{Fuzzy Control System:} The Fuzzy Control System combines all the concepts described above to create a system that can evaluate a set of fuzzy rules and generate an output based on the input variables. Such a control system acts like a black box $f: \mathbb{R}^n \rightarrow \mathbb{R}$ that takes a set of crisp input variables and returns the predicted value.
\end{itemize}

A simplified class diagram of the Fuzzy Tuning strategy can be seen in \autoref{fig:classdiagram}.

\begin{figure}[h]
  \centering
  \includesvg[width=\textwidth]{figures/class-diagram.svg}
  \caption[Class diagram of the Fuzzy Tuning Strategy]{Simplified class diagram of the Fuzzy Tuning strategy. There is a clear separation between the implementation of the Fuzzy Logic framework and the tuning strategy. This allows for an easy reuse of the Fuzzy Logic framework in other parts of AutoPas if desired.}
  \label{fig:classdiagram}
\end{figure}


\begin{figure}[h]
  \centering
  \begin{tikzpicture}[scale=2,font=\tiny]


    \node [rectangle,rounded corners,draw,inner sep=2pt] (A) at (0,0) {
      \fuzzySetNodeTwoD{x}{y}{$(x=low \lor y=big) \land \neg (x = high)$}{min(max(trapezoid(x,-10,-10,-2,0), trapezoid(y,1,2,10,10)),1-gaussian(x,2,1))}
    };

    \node [rectangle,rounded corners,draw,inner sep=5pt, inner ysep=10pt,fill=blue!30] (X) at (0,-1.5) {
      $\min$
    };


    \node [rectangle,rounded corners,draw,inner sep=2pt] (B) at (-2,-2.5) {
      \fuzzySetNodeTwoD{x}{y}{$x=low \lor y=big$}{max(trapezoid(x,-10,-10,-2,0), trapezoid(y,1,2,10,10))}
    };

    \node [rectangle,rounded corners,draw,inner sep=2pt] (C) at (2,-2.5) {
      \fuzzySetNodeOneD{x}{$\neg (x = high)$}{0}{1-gaussian(x,2,1)}
    };


    \node [rectangle,rounded corners,draw,inner sep=5pt, inner ysep=10pt,fill=blue!30] (Y) at (-2,-4) {
      $\max$
    };

    \node [rectangle,rounded corners,draw,inner sep=5pt, inner ysep=10pt,fill=blue!30] (Z) at (2,-3.75) {
      $1 - \cdot$
    };


    \node [rectangle,rounded corners,draw,inner sep=2pt] (D) at (-3.5,-5) {
      \fuzzySetNodeOneD{x}{$x = low$}{0}{trapezoid(x,-10,-10,-2,0)}
    };

    \node [rectangle,rounded corners,draw,inner sep=2pt] (E) at (-0.5,-5) {
      \fuzzySetNodeOneD{y}{$y = big$}{0}{trapezoid(x,1,2,10,10)}
    };

    \node [rectangle,rounded corners,draw,inner sep=2pt] (F) at (2,-5) {
      \fuzzySetNodeOneD{x}{$x = high$}{0}{gaussian(x,2,1)}
    };



    \node [rectangle,rounded corners,draw,inner sep=5pt, inner ysep=10pt,fill=red!30] (G) at (-3.5,-6.5) {
      \large $f_{trapezoid}$
    };

    \node [rectangle,rounded corners,draw,inner sep=5pt, inner ysep=10pt,fill=red!30] (H) at (-0.5,-6.5) {
      \large $f_{trapezoid}$
    };

    \node [rectangle,rounded corners,draw,inner sep=5pt, inner ysep=10pt,fill=red!30] (I) at (2,-6.5) {
      \large $f_{gaussian}$
    };


    \draw[->,ultra thick,draw = blue] (A) -- (X);
    \draw[->,ultra thick,draw = blue] (X) -- (B);
    \draw[->,ultra thick,draw = blue] (X) -- (C);


    \draw[->,ultra thick,draw = blue] (B) -- (Y);
    \draw[->,ultra thick,draw = blue] (Y) -- (D);
    \draw[->,ultra thick,draw = blue] (Y) -- (E);

    \draw[->,ultra thick,draw = blue] (C) -- (Z);
    \draw[->,ultra thick,draw = blue] (Z) -- (F);

    \draw[->,ultra thick,draw = red] (D) -- (G);
    \draw[->,ultra thick,draw = red] (E) -- (H);
    \draw[->,ultra thick,draw = red] (F) -- (I);
  \end{tikzpicture}

  \caption[Example of modular fuzzy set construction]{Recursive construction of a complex fuzzy set from simpler fuzzy sets. Using the linguistic variables $x$ with the terms $\{low, high\}$ and $y$ with the terms $\{big, small\}$ we can construct the fuzzy set $(x=low \lor y=big) \land \neg (x = high)$ by combining the fuzzy sets $x=low \lor y=big$ and $\neg (x = high)$. Those fuzzy sets are again constructed from the simpler fuzzy sets $x=low$, $y=big$ and $x=high$.

    The fuzzy sets at the leaf level can be directly constructed using predefined \textcolor{red}{\texttt{BaseMembershipFunctions}} (e.g. trapezoid, sigmoid, gaussian \dots) and provide the foundation for the more complex fuzzy sets
    All other fuzzy sets are created by combining other fuzzy sets using \textcolor{blue}{\texttt{CompositeMembershipFunctions}}. The logical operators $\min$, $\max$ and $1 - \cdot$ are implemented this way, as they directly act on top of other fuzzy sets.}
  \label{fig:modularfuzzysetconstruction}
\end{figure}



\section{Tuning Strategy}

The Tuning Strategy implements the interface between the Fuzzy Tuning framework and the AutoPas simulation. It is responsible for interacting with AutoPas and updating the queue of configurations.

It does this by evaluating all Fuzzy Systems present in the rule file with the current LiveInformation of the simulation. The LiveInformation is a snapshot of the current state of the simulation and contains summary statistics about various aspects of the simulation such as the number of particles, the average density of the particles or the total number of particles. Each evaluation of a Fuzzy Control System yields a single numeric value which is then passed on to the \texttt{OutputMapper} which assigns the associated configurations to this predicted value.

This method of assigning concrete configurations to the continuous output space of the Fuzzy Control Systems is inspired by Mohammed et al.~\cite{Mohammed2022}'s work on scheduling algorithms. Internally the \texttt{OutputMapper} stores an ideal location for each of the available configurations and determines the configuration located closest to the predicted value.

The resulting list of configurations predicted by the Fuzzy Tuning Strategy is then used to update the configuration queue of AutoPas. In the following iterations, all of those configurations are used to run a few steps of the simulation and the configuration with the best performance is then used for the following simulation-phase.

Currently two different modes of interpreting the rules are implemented:

\subsection{Individual Tuning Approach}

A more lightweight approach is the Parameter Tuning Approach. This approach creates a single Fuzzy Control System for each tunable parameter. All Fuzzy Control Systems then attempt to independently predict the optimal value for their respective parameter. Using this approach, the rule file only needs to define $\#Parameters$ Fuzzy Control Systems which is much more manageable. The drawback of this approach is that the continuous output space of the Fuzzy Control Systems needs to be directly translated to discrete values, which is a non-trivial task. The main problem lies in the fact that the tunable parameters are nominal values and thus have no natural order. This means that the interpolation between different linguistic terms, which is naturally performed by the Fuzzy Control Systems, is not meaningful in this context. To avoid this problem, we can however use a defuzzification method that does not rely on performing some kind of interpolation. One such method is the \gls{som} method which selects the smallest $x$-value for which the membership function is maximal. By using this method there is only a discrete set of possible outputs which can be directly mapped to the nominal values of the tunable parameters by making use of the OutputMapping construct of the Rule Parser. Since there is no interpolation between the linguistic terms, the order of the terms in the OutputMapping can be chosen arbitrarily.

\todo{find citations for fuzzy rules for nominal values}

\todo{link to later section}


\subsection{Suitability Tuning Approach}

The Suitability Approach is designed to tackle rule bases that try to directly predict a suitability value for \emph{each} configurations. This means that the rule file needs to define $\#Containers \cdot \#Traversals \cdot \#DataLayouts \cdot \#Newton3\_options$ different Fuzzy Control Systems. One for each possible configuration of those parameters. As a result, we receive a direct ranking (lets say from 0 to 100\% applicability) for each configuration. The Tuning Strategy then selects all configurations within a certain threshold of the highest ranking configuration and rewrites the queue of configurations with these selected configurations.

This method is a natural choice for rule bases as its style closely relates to the idea of Fuzzy Control Systems. It is possible to make full use of the continuous output space of the Fuzzy Control Systems and the method provides a straight forward mapping to the discrete AutoPas configuration space.

The huge downside of this approach is the need to define massive amount of Fuzzy Control Systems and rules in the rule file. This leads to a very big rule file which quickly becomes infeasible to maintain by hand.


\todo{link to later section}


\section{Rule Parser}

The Rule Parser is responsible for parsing the rule base supplied by the user and converting it into the internal representation used by the Fuzzy Tuning framework. It makes use of the ANTLR4\footnote{https://www.antlr.org/} parser generator to create a parser for a domain-specific language tailored to the needs of the Fuzzy Tuning. The language is inspired by common standards such as the Fuzzy Control Language (FCL)\footnote{https://www.fuzzylite.com/} but is designed to be more lightweight. The transformation of the parsed rules into the internal representation is done by a visitor pattern that traverses the parse tree generated by ANTLR4 and internally builds the corresponding objects of the Fuzzy Tuning framework.