\chapter{Implementation}
\label{sec:implementation}

\newcommand{\fuzzySetNodeOneD}[4]{
  \begin{tikzpicture}
    \begin{axis}%
      [
        axis line style={black},
        width=4.5cm,
        height=3cm,
        axis lines=center,
        xlabel={#1},
        x label style={at={(axis description cs:0.9,0.25)},anchor=north},
        ylabel=$\mu$,
        y label style={at={(axis description cs:0.5,1)},anchor=south},
        xmin=-6,
        xmax=6,
        ytick={},
        yticklabels={},
        extra x ticks={0},
        extra x tick labels={#3},
        ymax=1,
        samples=25,
        extra y ticks={1},
        every axis plot/.append style={thick}
      ]
      \addplot[red]  {#4};
    \end{axis}
    \node[above,font=\large\bfseries,inner sep=5pt] at (current bounding box.north) {\shortstack{FuzzySet\\#2}};
  \end{tikzpicture}
}

\newcommand{\fuzzySetNodeTwoD}[4]{
  \begin{tikzpicture}
    \begin{axis}%
      [
        width=5.5cm,
        height=4cm,
        axis lines=center,
        xlabel={#1},
        x label style={at={(axis description cs:0.1,0.4)},anchor=north},
        ylabel={#2},
        y label style={at={(axis description cs:0.4,-0.15)},anchor=south},
        zlabel=$\mu$,
        z label style={at={(axis description cs:0.5,0.95)},anchor=south},
        xmin=-6,
        xmax=6,
        colormap/viridis,
        view={10}{40},
        ymin=-6,
        ymax=6,
        zmin=0,
        zmax=1,
      ]
      \addplot3 [
        domain=-6:6,
        samples = 20,
        surf,
      ]{#4};
    \end{axis}
    \node[above,font=\large\bfseries,inner sep=5pt] at (current bounding box.north) { \shortstack{FuzzySet\\#3}};
  \end{tikzpicture}
}


This chapter describes the implementation of the Fuzzy Tuning technique in AutoPas. The implementation is divided into three main parts: the generic Fuzzy Logic framework, the Rule Parser, and the Fuzzy Tuning Strategy. The Fuzzy Logic framework is the core of this implementation and implements the mathematical foundation of this technique. The Rule Parser is responsible for parsing the rule base supplied by the user and converting it into the internal representation used by the Fuzzy Tuning framework. Finally, the Fuzzy Tuning Strategy is the interface between the Fuzzy Logic framework and the AutoPas simulation. It is responsible for updating the configuration queue to select configurations to be tested next.


\section{Fuzzy Tuning Framework}

The Fuzzy Tuning framework implements the mathematical foundation of the Fuzzy Tuning technique. It consists of several components that work together to fully describe the workflow of the fuzzy-rule evaluations. The components of the Fuzzy Tuning framework are as follows:

\begin{itemize}
  \item \textbf{Crisp Set}\\
        The Crisp Set models classical sets using k-cells and is used to define the underlying classical sets over which all fuzzy sets are defined. A k-cell is a hyperrectangle in the k-dimensional space constructed from the Cartesian product of k intervals $I = I_1 \times I_2 \times \ldots \times I_k$ where $I_i = [x_{low}, x_{high}] \subset \mathbb{R} $ is an interval in the real numbers. This cell defines the parameter space of the input variables, and its boundaries are later used for the numerical defuzzification step.


  \item \textbf{Fuzzy Set} \\
        As mentioned previously, fuzzy sets consist of a membership function assigning a degree of membership to each element of the Crisp Set. For the implementation in C++, we distinguish between two types of membership functions: The \texttt{BaseMembershipFunction} and the \texttt{CompositeMembershipFunction}. The \texttt{BaseMembershipFunction} acts as the standard membership function and directly assigns the degree of membership values to all continuous input values. It has the following signature: $f: \mathbb{R} \rightarrow [0, 1]$. Examples of this type of membership function are the trapezoid, sigmoid, and Gaussian functions described in the previous chapter. \\
        \smallskip
        The \texttt{CompositeMembershipFunctions} implement the logical operations. They act as links between existing fuzzy sets to create more complex ones. This helps to split up the complex fuzzy sets of the rule base into smaller, more manageable parts. Internally, this way of combining fuzzy sets builds a tree structure where the leave nodes can directly calculate membership value based on \texttt{BaseMembershipFunctions}, and the inner nodes combine those membership values and pass them up to their parents. This way of defining fuzzy sets is natural and allows for efficient membership evaluation. \autoref{fig:modularfuzzysetconstruction} shows how complex fuzzy sets can be constructed from simpler fuzzy sets using the \texttt{CompositeMembershipFunctions}. Each fuzzy set additionally provides a method to calculate the defuzzified value.

  \item \textbf{Linguistic Variable}\\
        Linguistic variables act as a container for the fuzzy sets. They group linguistic terms of the same concept and provide ways to access the fuzzy sets.

  \item \textbf{Fuzzy Rule}\\
        Fuzzy rules store an antecedent and a consequent fuzzy set. Additionally, they provide a method to evaluate the fuzzy set resulting from the rule activation based on the input variables.

  \item \textbf{Fuzzy Control System:} The Fuzzy Control System combines all the concepts described above to create a system that can evaluate a set of fuzzy rules and generate an output based on the input variables. Such a control system acts like a black box $f: \mathbb{R}^n \rightarrow \mathbb{R}$ that maps crisp input values to a crisp output value. Multiple such systems are used in later sections to implement the tuning strategy.
\end{itemize}

A simplified class diagram of the Fuzzy Tuning strategy can be seen in \autoref{fig:classdiagram}.

\newpage




\begin{figure}[H]
  \centering
  \begin{tikzpicture}[scale=2,font=\tiny]


    \node [rectangle, rounded corners, draw, inner sep=2pt] (A) at (0,0) {
      \fuzzySetNodeTwoD{x}{y}{$(x=low \lor y=big) \land \neg (x = high)$}{min(max(trapezoid(x,-10,-10,-2,0), trapezoid(y,1,2,10,10)),1-gaussian(x,2,1))}
    };

    \node [rectangle,rounded corners,draw,inner sep=5pt, inner ysep=10pt,fill=blue!30] (X) at (0,-1.5) {
      $\min$
    };


    \node [rectangle,rounded corners,draw,inner sep=2pt] (B) at (-2,-2.5) {
      \fuzzySetNodeTwoD{x}{y}{$x=low \lor y=big$}{max(trapezoid(x,-10,-10,-2,0), trapezoid(y,1,2,10,10))}
    };

    \node [rectangle,rounded corners,draw,inner sep=2pt] (C) at (2,-2.5) {
      \fuzzySetNodeOneD{x}{$\neg (x = high)$}{0}{1-gaussian(x,2,1)}
    };


    \node [rectangle,rounded corners,draw,inner sep=5pt, inner ysep=10pt,fill=blue!30] (Y) at (-2,-4) {
      $\max$
    };

    \node [rectangle,rounded corners,draw,inner sep=5pt, inner ysep=10pt,fill=blue!30] (Z) at (2,-3.75) {
      $1 - \cdot$
    };


    \node [rectangle,rounded corners,draw,inner sep=2pt] (D) at (-3.5,-5) {
      \fuzzySetNodeOneD{x}{$x = low$}{0}{trapezoid(x,-10,-10,-2,0)}
    };

    \node [rectangle,rounded corners,draw,inner sep=2pt] (E) at (-0.5,-5) {
      \fuzzySetNodeOneD{y}{$y = big$}{0}{trapezoid(x,1,2,10,10)}
    };

    \node [rectangle,rounded corners,draw,inner sep=2pt] (F) at (2,-5) {
      \fuzzySetNodeOneD{x}{$x = high$}{0}{gaussian(x,2,1)}
    };



    \node [rectangle,rounded corners,draw,inner sep=5pt, inner ysep=10pt,fill=red!30] (G) at (-3.5,-6.5) {
      \large $f_{trapezoid}$
    };

    \node [rectangle,rounded corners,draw,inner sep=5pt, inner ysep=10pt,fill=red!30] (H) at (-0.5,-6.5) {
      \large $f_{trapezoid}$
    };

    \node [rectangle,rounded corners,draw,inner sep=5pt, inner ysep=10pt,fill=red!30] (I) at (2,-6.5) {
      \large $f_{gaussian}$
    };


    \draw[->,ultra thick,draw = blue] (A) -- (X);
    \draw[->,ultra thick,draw = blue] (X) -- (B);
    \draw[->,ultra thick,draw = blue] (X) -- (C);


    \draw[->,ultra thick,draw = blue] (B) -- (Y);
    \draw[->,ultra thick,draw = blue] (Y) -- (D);
    \draw[->,ultra thick,draw = blue] (Y) -- (E);

    \draw[->,ultra thick,draw = blue] (C) -- (Z);
    \draw[->,ultra thick,draw = blue] (Z) -- (F);

    \draw[->,ultra thick,draw = red] (D) -- (G);
    \draw[->,ultra thick,draw = red] (E) -- (H);
    \draw[->,ultra thick,draw = red] (F) -- (I);
  \end{tikzpicture}

  \caption[Example of modular fuzzy set construction]{Recursive construction of a complex fuzzy set from simpler fuzzy sets. Using the linguistic variables $x$ with the terms $\{low, high\}$ and $y$ with the terms $\{big, small\}$ we can construct the fuzzy set $(x=low \lor y=big) \land \neg (x = high)$ by combining the fuzzy sets $x=low \lor y=big$ and $\neg (x = high)$. Those fuzzy sets are again constructed from the simpler fuzzy sets $x=low$, $y=big$ and $x=high$.

    The fuzzy sets at the leaf level can be directly constructed using predefined \textcolor{red}{\texttt{BaseMembershipFunctions}} (e.g., trapezoid, sigmoid, gaussian \dots) and provide the foundation for the more complex fuzzy sets
    All other fuzzy sets are created by combining other fuzzy sets using \textcolor{blue}{\texttt{CompositeMembershipFunctions}}. The logical operators $\min$, $\max$, and $1 - \cdot$ are implemented this way, as they directly act on top of other fuzzy sets.}
  \label{fig:modularfuzzysetconstruction}
\end{figure}

\begin{figure}[H]
  \centering
  \includesvg[width=\textwidth]{figures/class-diagram.svg}
  \caption[Class diagram of the Fuzzy Tuning Strategy]{Simplified class diagram of the Fuzzy Tuning strategy. There is a clear separation between implementing the Fuzzy Logic framework and the tuning strategy. This allows for an easy reuse of the Fuzzy Logic framework in other parts of AutoPas if desired.}
  \label{fig:classdiagram}
\end{figure}


\section{Rule Parser}

The Rule Parser is responsible for parsing the rule base supplied by the user and converting it into the internal representation used by the Fuzzy Tuning framework. It uses the ANTLR4\footnote{https://www.antlr.org/} parser generator to create a parser for a domain-specific language tailored to the needs of the Fuzzy Tuning. The language is inspired by common standards such as the Fuzzy Control Language (FCL)\footnote{https://www.fuzzylite.com/} but is designed to be more lightweight and directly incorporate aspects of the AutoPas simulation.
The parsed rules are transformed into the internal representation by a visitor pattern that traverses the parse tree generated by ANTLR4 and internally builds the corresponding object hierarchy.

\section{Tuning Strategy}

The Tuning Strategy implements the interface between the Fuzzy Tuning framework and the AutoPas simulation and is responsible for updating the configuration queue of configurations to be tested next.

It does this by evaluating all fuzzy systems present in the rule file with the current information on the simulation. It primarily used \emph{LiveInformation} data, containing summary statistics about various aspects of the current simulation state. Possible parameters include the total number of particles, the average density, or the average homogeneity of the particle distribution. Each evaluation of a Fuzzy Control System yields a single numeric value, which is then passed on to the \texttt{OutputMapper}, which determines the resulting configuration. Such a mapping is necessary because the output of the Fuzzy Control System is a continuous value, while the configuration space of AutoPas is discrete, and we need to define mappings between the two.

This method of assigning concrete configurations to the continuous output space of the Fuzzy Control Systems is inspired by Mohammed et al.~\cite{Mohammed2022}'s work on scheduling algorithms. Internally, the \texttt{OutputMapper} stores an ideal location for each available configuration and determines the configuration closest to the predicted value.

The resulting list of configurations predicted by the Fuzzy Tuning Strategy is then used to update AutoPas's configuration queue. In the following iterations, all of those configurations are used to run a few steps of the simulation, and the configuration with the best performance is then used for the following simulation phase.

Currently, two different modes of interpreting the rules are implemented:

\subsection{Component Tuning Approach}

The component Tuning Approach expects a single Fuzzy Control System for each tunable parameter. All those Fuzz Systems should then attempt to predict the best value of their parameter independent of the other parameters. This approach requires the rule file to only define $\#Parameters$ different Fuzzy Control Systems, which makes it easier to maintain and understand. An obvious drawback of this method is the independence assumption between the parameters, which might not hold in practice.

Another problem of this approach lies in the defuzzification step. As this method relies on defining a single system for all parameter values, there must be a \emph{ranking} of all those values on a single numeric scale. Such a ranking is problematic, as most tunable values are nominal and do not have a natural order. To circumvent this problem, we can use a defuzzification method that does not perform interpolations between the values. Using such a method, the placement of the linguistic terms can be arbitrary. One such method is \gls{mom}. It selects the mean of all $x$-values for which the membership function is maximal. When using Gaussian-shaped membership functions, this method will only ever return the mean of the Gaussian with the highest activation. The OutputMapper can directly take these values and assign them to the corresponding nominal value of the tunable parameter. All predicted values are then used to filter the configuration queue, excluding all configurations that do not match the predicted values.

\autoref{fig:fuzzyInferenceSystemIndividual} shows a schematic of the Component Tuning Approach.


\begin{figure}[H]
  \centering

  \newcommand{\xShift}{0.15}
  \newcommand{\yShift}{0.27}
  \newcommand{\scaleShift}{0.1}
  \begin{tikzpicture}[scale=2,font=\small]
    \node[anchor=east] (L) at (-3,-0.6) {$\text{LiveInfo} \in \mathbb{R}^d$};

    \foreach \name [count=\i from 0] in { Newton3, DataLayout, Traversal, Container}
      {
        \pgfmathsetmacro{\scaleFactor}{1 + \i*\scaleShift}

        \node [rectangle,rounded corners,draw,inner sep=2pt,fill=white!80!black,scale=\scaleFactor,anchor=east] (A) at (0-\i * \xShift,0-\i * \yShift) {
          \begin{tikzpicture}[font=\small]
            \begin{axis}%
              [
                title={FCS [\name]},
                width=3.8cm,
                height=2.2cm,
                axis lines=center,
                xmin=0,
                xmax=4,
                xlabel={$\mathbb{R}$},
                x label style={at={(axis description cs:1,0.2)},anchor=west},
                ylabel=$\mu$,
                y label style={at={(axis description cs:0,0.8)},anchor=east},
                xtick={},
                xticklabels= {},
                ytick={},
                yticklabels={},
                ymax=1,
                every axis plot/.append style={thick},
                domain=0:4
              ]
              \addplot[blue, samples=17] {gaussian(x,1,0.2)};
              \addplot[red,samples=15] {gaussian(x,2,0.2)};
              \addplot[green,samples=17] {gaussian(x,3,0.2)};
            \end{axis}
          \end{tikzpicture}
        };

        \node [rectangle,rounded corners,draw,inner sep=2pt,fill=white!80!black,scale=\scaleFactor*1.1,anchor=east] (O) at (1.45-\i *\xShift*0.2,0-\i*\yShift) {\tiny{OutputMapper}};

        \node[scale=\scaleFactor*1.2, anchor=west] (T) at (1.85-\i*\xShift*0.3,0-\i*\yShift) {\tiny{\name Option}};

        \draw[->, thick] (L.east) -- (A.west) ;

        \draw[->, thick] (A.east) -- (O.west) ;
        \draw[->, thick] (O.east) -- (T.west) ;
      }

  \end{tikzpicture}

  \caption[Visualization of the fuzzy control systems for the Component Tuning Approach]{Example Visualization of the fuzzy control systems for the Component Tuning Approach. The parameters \texttt{Container}, \texttt{Traversal}, \texttt{DataLayout}, and \texttt{Newton3} are tuned independently. The OutputMapper assigns the predicted values to the corresponding nominal values of the parameters.}
  \label{fig:fuzzyInferenceSystemIndividual}

\end{figure}


\subsection{Suitability Tuning Approach}

The Suitability Approach differs from the Component Tuning Approach in that it utilizes $\#Container\_options \cdot \#Traversal\_options \cdot \#DataLayout\_options \cdot \#Newton3\_options$ different Fuzzy Control Systems, one for each possible combination of those parameters. Consequently, there are way more Fuzzy Control Systems to evaluate. The advantage of this approach is that there is no need to rank the output values, and one can utilize the power of interpolation between different predictions by using the \gls{cog} defuzzification method as the predicted suitabilities have a natural order. Furthermore, dependencies and incompatibilities between the parameters can be modeled accurately. The downside is the increased complexity of the rule file, which quickly becomes infeasible to maintain by hand. Surprisingly, the cost of evaluating all those Fuzzy Control Systems is negligible compared to the overhead of other tuning strategies.

Each System is responsible for predicting the suitability of a specific configuration, ranging from 0 (not suitable) to 100\% (perfectly suitable). After applying the OutputMapping, the Strategy selects all configurations performing within a certain threshold of the best configuration and rewrites the configuration queue accordingly. \autoref{fig:fuzzyInferenceSystemSuitability} shows a schematic of the Suitability Tuning Approach.

\begin{figure}[H]
  \centering

  \newcommand{\xShift}{0.03}
  \newcommand{\yShift}{0.13}
  \newcommand{\scaleShift}{0.066}

  \begin{tikzpicture}[scale=2,font=\small]
    \node[anchor=east] (L) at (-3.5,-1.5) {$\text{LiveInfo} \in \mathbb{R}^d$};

    \foreach \name [count=\i from 0] in {15,...,1}
      {
        \pgfmathsetmacro{\scaleFactor}{1 + \i*\scaleShift}
        \pgfmathsetmacro{\opacity}{0 + 1*\i/6}
        \pgfmathsetmacro{\arrowThickness}{0.2 + 1.8*\i/16}


        \node [rectangle,rounded corners,draw,inner sep=2pt,fill=white!80!black, fill opacity=\opacity, draw opacity=\opacity,scale=\scaleFactor,anchor=east] (A) at (0-\i * \xShift,0-\i * \yShift) {
          \begin{tikzpicture}[font=\tiny]
            \begin{axis}%
              [
                title={FCS [Combination\textsubscript {\ifthenelse{\name<10}{\name\space}{\name}}]},
                width=3cm,
                height=2cm,
                axis lines=center,
                xmin=0,
                xmax=4,
                xlabel={$\mathbb{R}$},
                x label style={at={(axis description cs:1,0.2)},anchor=west},
                ylabel=$\mu$,
                y label style={at={(axis description cs:0,0.8)},anchor=east},
                xtick={},
                xticklabels= {},
                ytick={},
                yticklabels={},
                ymax=1,
                every axis plot/.append style={thick},
                domain=0:4
              ]
              \addplot[blue, samples=17] {gaussian(x,1,0.2)};
              \addplot[red,samples=15] {gaussian(x,2,0.2)};
              \addplot[green,samples=17] {gaussian(x,3,0.2)};
            \end{axis}
          \end{tikzpicture}
        };

        \node [rectangle,rounded corners,draw,inner sep=2pt,fill=white!80!black, fill opacity=\opacity, draw opacity=\opacity,scale=\scaleFactor*0.8,anchor=east] (O) at (1+\i *\xShift*1,0-\i*\yShift) {\tiny{OutputMapper}};

        \node[scale=\scaleFactor*0.8,fill opacity=\opacity, draw opacity=\opacity, anchor=west] (T) at (1.3+\i*\xShift*1,0-\i*\yShift) {\tiny{ Configuration {\ifthenelse{\name<10}{\name\space}{\name}}}};

        \node[scale=\scaleFactor*0.8,fill opacity=\opacity, draw opacity=\opacity, anchor=west] (S) at (1.25+\i*\xShift*1,-0.2-\i*\yShift) {};

        \draw[->,thick,fill opacity=\opacity, draw opacity=\opacity,] (L.east) -- (A.west) ;

        \draw[->,thick,fill opacity=\opacity, draw opacity=\opacity,] (A.east) -- (O.west) ;
        \draw[->,thick,fill opacity=\opacity, draw opacity=\opacity,] (O.east) -- (T.west) ;

        \draw[thick, fill opacity=\opacity, draw opacity=\opacity]
        (A.east) edge[bend right, looseness=0.5, ->]
        (S.south west) ;
      }

  \end{tikzpicture}

  \caption[Visualization of the fuzzy control systems for the Suitability Tuning Approach]{Example Visualization of the fuzzy control systems for the Suitability Tuning Approach. Each Fuzzy Control System is responsible for predicting the suitability of a specific configuration. The suitability and the mapped configuration are passed on to the Strategy, which only considers highly suitable configurations for the next simulation steps.}
  \label{fig:fuzzyInferenceSystemSuitability}
\end{figure}

